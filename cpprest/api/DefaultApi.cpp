/**
 * Hockeyapp Public API wrapper
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


#include "DefaultApi.h"
#include "IHttpBody.h"
#include "JsonBody.h"
#include "MultipartFormData.h"

#include <unordered_set>

#include <boost/algorithm/string/replace.hpp>

namespace com {
namespace github {
namespace panthro {
namespace hockeyapp {

using namespace io::swagger::client::model;

DefaultApi::DefaultApi( std::shared_ptr<ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

DefaultApi::~DefaultApi()
{
}

pplx::task<std::shared_ptr<Apps>> DefaultApi::appsGet()
{
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/apps");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
        
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->appsGet does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
        
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("DefaultApi->appsGet does not consume any supported media type"));
    }    
    
    // authentication (token) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-HockeyAppToken"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-HockeyAppToken")] = apiKey;
        }
    }
    
    return m_ApiClient->callApi(path, U("GET"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK 
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling appsGet: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling appsGet: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<Apps> result(new Apps());
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
            throw ApiException(500
                , U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}
pplx::task<std::shared_ptr<App>> DefaultApi::appsUploadPost(std::shared_ptr<HttpContent> ipa, std::shared_ptr<HttpContent> dsym, utility::string_t notes, int32_t notesType, int32_t notify, int32_t status, utility::string_t strategy, std::vector<utility::string_t> tags, std::vector<int32_t> teams, std::vector<int32_t> users, int32_t mandatory, int32_t releaseType, bool private, int32_t ownerId, utility::string_t commitSha, utility::string_t buildServerUrl, utility::string_t repositoryUrl)
{
    
    // verify the required parameter 'ipa' is set
    if (ipa == nullptr)
    {
        throw ApiException(400, U("Missing required parameter 'ipa' when calling DefaultApi->appsUploadPost"));
    }
    
    
    std::shared_ptr<ApiConfiguration> apiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t path = U("/apps/upload");
        
    std::map<utility::string_t, utility::string_t> queryParams;
    std::map<utility::string_t, utility::string_t> headerParams( apiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> formParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> fileParams;

    std::unordered_set<utility::string_t> responseHttpContentTypes;
    responseHttpContentTypes.insert( U("application/json") );
    
    utility::string_t responseHttpContentType;
    
    // use JSON if possible
    if ( responseHttpContentTypes.size() == 0 || responseHttpContentTypes.find(U("application/json")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("application/json");
    }
    // multipart formdata 
    else if( responseHttpContentTypes.find(U("multipart/form-data")) != responseHttpContentTypes.end() )
    {
        responseHttpContentType = U("multipart/form-data");
    }
    else
    {
        throw ApiException(400, U("DefaultApi->appsUploadPost does not produce any supported media type"));
    }    
    
    headerParams[U("Accept")] = responseHttpContentType;
    
    std::unordered_set<utility::string_t> consumeHttpContentTypes;
    consumeHttpContentTypes.insert( U("multipart/form-data") );
    
    if (ipa != nullptr)
    {
        fileParams[ U("Ipa") ] = ipa;
        
    }
    if (dsym != nullptr)
    {
        fileParams[ U("dsym") ] = dsym;
        
    }
    
    {
        formParams[ U("notes") ] = ApiClient::parameterToString(notes);
        
    }
    
    {
        formParams[ U("notes_type") ] = ApiClient::parameterToString(notesType);
        
    }
    
    {
        formParams[ U("notify") ] = ApiClient::parameterToString(notify);
        
    }
    
    {
        formParams[ U("status") ] = ApiClient::parameterToString(status);
        
    }
    
    {
        formParams[ U("strategy") ] = ApiClient::parameterToString(strategy);
        
    }
    
    {
        formParams[ U("tags") ] = ApiClient::parameterToArrayString<>(tags);
        
    }
    
    {
        formParams[ U("teams") ] = ApiClient::parameterToArrayString<>(teams);
        
    }
    
    {
        formParams[ U("users") ] = ApiClient::parameterToArrayString<>(users);
        
    }
    
    {
        formParams[ U("mandatory") ] = ApiClient::parameterToString(mandatory);
        
    }
    
    {
        formParams[ U("release_type") ] = ApiClient::parameterToString(releaseType);
        
    }
    
    {
        formParams[ U("private") ] = ApiClient::parameterToString(private);
        
    }
    
    {
        formParams[ U("owner_id") ] = ApiClient::parameterToString(ownerId);
        
    }
    
    {
        formParams[ U("commit_sha") ] = ApiClient::parameterToString(commitSha);
        
    }
    
    {
        formParams[ U("build_server_url") ] = ApiClient::parameterToString(buildServerUrl);
        
    }
    
    {
        formParams[ U("repository_url") ] = ApiClient::parameterToString(repositoryUrl);
        
    }
    

    std::shared_ptr<IHttpBody> httpBody;
    utility::string_t requestHttpContentType;
   
    // use JSON if possible
    if ( consumeHttpContentTypes.size() == 0 || consumeHttpContentTypes.find(U("application/json")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("application/json");

    }
    // multipart formdata 
    else if( consumeHttpContentTypes.find(U("multipart/form-data")) != consumeHttpContentTypes.end() )
    {
        requestHttpContentType = U("multipart/form-data");
        
    }
    else
    {
        throw ApiException(415, U("DefaultApi->appsUploadPost does not consume any supported media type"));
    }    
    
    // authentication (token) required
    {
        utility::string_t apiKey = apiConfiguration->getApiKey(U("X-HockeyAppToken"));
        if ( apiKey.size() > 0 )
        {
            headerParams[U("X-HockeyAppToken")] = apiKey;
        }
    }
    
    return m_ApiClient->callApi(path, U("POST"), queryParams, httpBody, headerParams, formParams, fileParams, requestHttpContentType)
    .then([=](web::http::http_response response)
    {
        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK 
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (response.status_code() >= 400)
        {
            throw ApiException(response.status_code()
                , U("error calling appsUploadPost: ") + response.reason_phrase()
                , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
        }
        
        // check response content type
        if(response.headers().has(U("Content-Type")))
        {
            utility::string_t contentType = response.headers()[U("Content-Type")];
            if( contentType.find(responseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , U("error calling appsUploadPost: unexpected response type: ") + contentType
                    , std::make_shared<std::stringstream>(response.extract_utf8string(true).get()));
            }
        }
        
        return response.extract_string();
    })
    .then([=](utility::string_t response)
    {
        std::shared_ptr<App> result(new App());
        
        if(responseHttpContentType == U("application/json"))
        {
            web::json::value json = web::json::value::parse(response);
            
            result->fromJson(json);
        }
        // else if(responseHttpContentType == U("multipart/form-data"))
        // {
        // TODO multipart response parsing    
        // }
        else 
        {
            throw ApiException(500
                , U("error calling findPetsByStatus: unsupported response type"));
        }
        
        return result;
    });            
}

}
}
}
}

